"""
Calculate pitch trajectory considering
- Initial velocity
- Spin rate and axis
- Relase Height
Forces acting on the ball:
- Magnus force
- Drag force
- Gravity
Initially generated by ChatGPT. All vibe
Spins and velocities parameters are from Kyle Hendricks statcast + made up.
Definition of axis (centred at pitcher's foot):
X - mound to plate.
Y - Left/Right. Positive is to the left (RHP's glove-side)
Z - Vertical. 0 is ground. Positive is above ground.
Thus it is a right-hand axes

Statcast axis defnition:
X - Horizontal Left/Right
Y - Plate to mound. 0 is plate.
Z - Vertical
"""
from collections import Counter

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd
import tqdm

from utils.units import rpm_to_radps, feet_to_meter
from utils.pitch_traj_sim import simulate_pitch_3d, MOUND2PLATE_METERS

# Convert spin axis (degrees) to 3d vector (normalized)
def spindeg_to_spinvec(axis_deg):
    """
    axis_deg : directly from StatCast
    output coordinate system: ours (not statCast)
    """
    theta = np.deg2rad(axis_deg)
    # axis_deg: on YZ plane 180° = pure backspin fastabll, 0° = pure topspin curveball
    return np.array([
        0,   # X-component
        np.cos(theta),   # Y-component
        -np.sin(theta),    # Z-component
    ])
    # ~ return spin_rad * np.array([
        # ~ np.cos(theta),   # X-component
        # ~ np.sin(theta),   # Y-component
        # ~ 0                # Z-component
    # ~ ])


def simulate_physics(p0, v0, spin_rpm, spin_axis_deg):
    params = {}
    params["p0"] = p0
    params["spin_rpm"] = spin_rpm
    params["axis"] = spindeg_to_spinvec(spin_axis_deg)
    params["v0_meterspersec"] = v0
    return simulate_pitch_3d(params)[0]

# Statcast-based simulation
def simulate_statcast(p0, v0, a_stat, dt=0.001, max_time=1.0):
    v = v0.copy()
    p = p0.copy()  # Initial position (m)
    trajectory = [p.copy()]
    for _ in np.arange(0, max_time, dt):
        v += a_stat * dt
        p += v * dt
        trajectory.append(p.copy())
        if p[0]>=MOUND2PLATE_METERS or p[2]<=0:
            break
    return np.array(trajectory)

def simulate_one_pitch(df_statcast, i_pitch, plot):
    pitch_type = df_statcast.iloc[i_pitch]["pitch_type"]
    # Initial conditions from Statcast data
    vx0 = -feet_to_meter(df_statcast.iloc[i_pitch]["vy0"])  # Mound to plate
    vy0 = -feet_to_meter(df_statcast.iloc[i_pitch]["vx0"])  # Pitcher to his left
    vz0 = feet_to_meter(df_statcast.iloc[i_pitch]["vz0"])   # Vertical velocity component (m/s)
    x0 = MOUND2PLATE_METERS - feet_to_meter(df_statcast.iloc[i_pitch]["release_pos_y"])
    y0 = -feet_to_meter(df_statcast.iloc[i_pitch]["release_pos_x"])
    z0 = feet_to_meter(df_statcast.iloc[i_pitch]["release_pos_z"])
    v0 = np.array([vx0, vy0, vz0])
    p0 = np.array([x0, y0, z0])
    # print(v0)
    # Statcast-provided accelerations (m/s^2)
    ax_stat = feet_to_meter(df_statcast.iloc[i_pitch]["ay"])
    ay_stat = -feet_to_meter(df_statcast.iloc[i_pitch]["ax"])
    az_stat = feet_to_meter(df_statcast.iloc[i_pitch]["az"])
    a_stat = np.array([ax_stat, ay_stat, az_stat])
    # print(a_stat)
    plate_y = -feet_to_meter(df_statcast.iloc[i_pitch]["plate_x"])
    plate_z = feet_to_meter(df_statcast.iloc[i_pitch]["plate_z"])
    # Spin parameters
    spin_rpm = df_statcast.iloc[i_pitch]["release_spin_rate"]
    spin_axis_deg = df_statcast.iloc[i_pitch]["spin_axis"]

    # Run simulations
    traj_statcast = simulate_statcast(p0, v0, a_stat)
    traj_physics = simulate_physics(p0, v0, spin_rpm, spin_axis_deg)

    ret_dict = {
        "traj_statcast": traj_statcast,
        "traj_physics": traj_physics,
        "plate_y": plate_y,
        "plate_z": plate_z,
        "pitch_type": pitch_type
    }

    if not plot:
        return ret_dict

    # Plotting the trajectories
    fig = plt.figure(figsize=(12, 6))
    ax = fig.add_subplot(111, projection='3d')
    ax.plot(traj_statcast[:, 0], traj_statcast[:, 1], traj_statcast[:, 2], label="Statcast Trajectory", color='red')
    ax.plot(traj_physics[:, 0], traj_physics[:, 1], traj_physics[:, 2], label="Physics-Based Trajectory", color='blue', linestyle='--')
    ax.scatter([MOUND2PLATE_METERS], [plate_y], [plate_z], marker="*", color="k")
    ax.set_zlim([0, ax.get_zlim()[1]])
    ax.set_xlabel("X (mound to plate) [m]")
    ax.set_ylabel("Y (horizontal) [m]")
    ax.set_zlabel("Z (vertical) [m]")
    ax.set_title("Kyle Hendricks' %s: Statcast vs. Physics-Based Simulation" % (pitch_type))
    ax.set_box_aspect((
        np.ptp(traj_statcast[:, 0]),
        np.ptp(traj_statcast[:, 1]),
        np.ptp(traj_statcast[:, 2])
        ))
    ax.legend()
    # def set_axes_equal(ax):
    #     """Make axes of 3D plot have equal scale so that spheres appear as spheres,
    #     cubes as cubes, etc. This is one possible solution to Matplotlib's lack
    #     of a built-in 3D aspect ratio control."""
    #     x_limits = ax.get_xlim3d()
    #     y_limits = ax.get_ylim3d()
    #     z_limits = ax.get_zlim3d(
    #     x_range = abs(x_limits[1] - x_limits[0])
    #     x_middle = np.mean(x_limits)
    #     y_range = abs(y_limits[1] - y_limits[0])
    #     y_middle = np.mean(y_limits)
    #     z_range = abs(z_limits[1] - z_limits[0])
    #     z_middle = np.mean(z_limits
    #     plot_radius = 0.5 * max([x_range, y_range, z_range]
    #     ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])
    #     ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])
    #     ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])
    # set_axes_equal(ax)
    plt.tight_layout()
    plt.show()

    return ret_dict

if __name__ == "__main__":
    data = pd.read_csv("data_kyle_cgso81.csv")
    n_pitches_all = len(data)
    # Filter out pitches with missing values
    data = data.dropna(subset=["release_pos_x", "release_pos_y", "release_pos_z", "vx0", "vy0", "vz0", "pitch_type"])
    # Filter out pitches with zero velocity
    data = data[(data["vx0"] != 0) | (data["vy0"] != 0) | (data["vz0"] != 0)]
    # Filter out pitches with zero spin rate
    data = data[data["release_spin_rate"] != 0]
    n_pitches = len(data)
    print("Total pitches: %d/%d" % (n_pitches, n_pitches_all))

    # Simulate and plot for each pitch
    res_dicts = []
    for i_pitch in tqdm.tqdm(range(n_pitches)):
        rd = simulate_one_pitch(data, i_pitch, plot=False)
        res_dicts.append(rd)
    pitch_types = [rd["pitch_type"] for rd in res_dicts]
    spot_physics = np.array([rd["traj_physics"][-1, 1:] for rd in res_dicts])
    dirt_physics = np.array([(rd["traj_physics"][-1, 0]<MOUND2PLATE_METERS) for rd in res_dicts], dtype=bool)
    spot_statcast = np.array([rd["traj_statcast"][-1, 1:] for rd in res_dicts])
    dirt_statcast = np.array([(rd["traj_statcast"][-1, 0]<MOUND2PLATE_METERS) for rd in res_dicts], dtype=bool)
    # TODO how does statcast count a pitch in dirt?
    spot_actual = np.array([[rd["plate_y"], rd["plate_z"]] for rd in res_dicts])
    nondirt_mask = (spot_actual[:, 1]>0)
    # nondirt_mask = ((~dirt_physics) & (~dirt_statcast))
    # Filter out pitches that hit the dirt
    spot_physics = spot_physics[nondirt_mask]
    spot_statcast = spot_statcast[nondirt_mask]
    spot_actual = spot_actual[nondirt_mask]
    pitch_types = [pitch_types[i] for i in range(len(pitch_types)) if nondirt_mask[i]]
    deviations_physics = spot_physics - spot_actual
    deviations_statcast = spot_statcast - spot_actual
    # Plotting the results
    print("Pitch composition:")
    print(Counter(pitch_types))
    pitch_types_uniq = list(set(pitch_types))
    pitch_type_str2idx = {cat: i for i, cat in enumerate(pitch_types_uniq)}
    pitch_type_indices = np.array([pitch_type_str2idx[pt] for pt in pitch_types])
    def plot_deviation(ax, errors, titlestr, pitch_type_str2idx, pitch_type_indices, cmap):
        colors = cmap(pitch_type_indices)
        scatter = ax.scatter(errors[:, 0], errors[:, 1], c=colors, alpha=0.5, s=7)
        # Create legend manually
        for pt_str, pt_idx in pitch_type_str2idx.items():
            ax.scatter([], [], color=cmap(pt_idx), label=pt_str)
        ax.legend()
        ax.set_title(titlestr)
        ax.set_xlabel("Y ERROR (LEFT) [m]")
        ax.set_ylabel("Z ERROR (UP) [m]")
        # ax.axis("equal")
        ax.grid(True)
    fig, axes = plt.subplots(1, 2, figsize=(12, 6), sharex=True, sharey=True)
    cmap = plt.get_cmap('tab10')
    plot_deviation(axes[0], deviations_physics[~dirt_physics], "Physics-Based Simulation", pitch_type_str2idx, pitch_type_indices[~dirt_physics], cmap)
    plot_deviation(axes[1], deviations_statcast[~dirt_statcast], "Statcast Simulation", pitch_type_str2idx, pitch_type_indices[~dirt_statcast], cmap)
    ymax = max(np.abs(deviations_physics[~dirt_physics, 1]).max(), np.abs(deviations_statcast[~dirt_statcast, 1]).max())*1.1
    xmax = max(np.abs(deviations_physics[~dirt_physics, 0]).max(), np.abs(deviations_statcast[~dirt_statcast, 0]).max())*1.1
    axes[0].set_xlim([-xmax, xmax])
    axes[0].set_ylim([-ymax, ymax])
    fig.suptitle("Deviation of physics simulation/statcast approximation from actual spot\nKyle Hendricks' Pitches")
    # fig.tight_layout()
    # fig.subplots_adjust(wspace=0.2)
    plt.show()